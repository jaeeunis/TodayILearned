# Modern Java In Action

## CHAPTER 3 람다 표현식

> 람다표현식은 메서드로 전달할 수 있는 **익명 함수**를 단순화한 것이라고 할 수 있다. 람다 표현식에는 이름은 없지만, 파라미터 리스트, 바디, 반환 형식, 발생할 수 있는 예외 리스트는 가질 수 있다. 람다를 이용하면 간결한 방식으로 코드를 전달할 수 있다. 

```java
(Coumputer c1, Computer c2) -> c1.getPrice().compreTo(c2.getPrice());
// 람다 파라미터									// 람다 바디
```

<br>

### 1. 어디에, 어떻게 람다를 사용할까!?

#### 1-1 함수형 인터페이스

함수형인터페이스라는 문맥에서 람다표현식을 사용할 수 있다. **함수형 인터페이스**는 정확히 **하나의 추상 메서드를 지정하는 인터페이스**이다. 람다 표현식으로 함수형 인터페이스의 추상 메서드 구현을 직접 전달할 수 있으므로 **전체 표현식을 함수형 인터페이스의 인스턴스로 취급 할 수 있다.** ( 내 경우에는 람다표현식 그 자체가 함수형 인터페이스라는 것으로 이해했다. )

```java
public interface Predicate<T> {
		boolean test(T t);
}

Runnable r1 = () -> System.out.println("Hello World 1"); // 함수형 인터페이스 람다로 표현
public static void process(Runnable r) {
  	r.run();
}
process(() -> System.out.println("Hello World 2")); // 파라미터 값을 람다표현으로 표현
```

#### 1-2 함수 디스크립터

함수형 인터페이스의 추상 메서드 **시그니처(signature)**는 람다 표현식의 시그니처를 가리킨다. 람다 표현식의 시그니처를 서술하는 메서드를 **함수 디스크립터(function descripter)**라고 부른다. 위에서 Predicate 인터페이스의 유일한 추상 메서드 test는 int 인수와 boolean반환값이 있는 시그니처로 생각할 수 있다.

#### 1-3 왜 함수형 인터페이스를 인수로 받는 메서드에만 람다 표현식을 사용할 수 있을까?

자바에 함수형식을 추가하는 방법도 고려했지만 언어를 더이상 복잡하게 만들지 않는 것을 선택했다. 또한 대부분의 자바 프로그래가 하나의 추상 메서드를 갖는 인터페이스에 이미 익숙하다는 점을 고려했다. 

#### 1-4 @Functionalinterface 

새로운 자바 API를 살펴보면 @Functionallinterface 어노테이션이 추가되어 있다. 함수형 인터페이스를 가리키는 어노테이션이다. 인터페이스를 선언했지만 실제로 함수형 인터페이스가 아니면 컴파일러가 에러를 발생시킨다. 예를 들어 추상 메서드가 한 개 이상이라면 에러를 발생시킨다. ("Multiple nonoverriding abstract methods found in interface Jaeeun")

<br>

### 2. 람다 활용 : 실행 어라운드 패턴

자원 처리에 사용하는 순환 패턴은 자원은 열고, 처리한 다음에, 자원을 닫는 순서로 이루어진다. 즉 실제 자원을 처리하는 코드를 설정과 정리 두과정이 둘러싸는 형태를 갖는 형식의 코드를 **실행 어라운드 패턴(excute around pattern)**이라고 부른다.

```java
public String processFile() throws IOException {
	try (BufferedReader br = new BufferedReader (new FileReader("moden.txt"))) {
		return br.readLine(); // 실제 파일을 읽는 (실제 필요한 작업) 코드
	} 
}
```

#### 2-3 동작 파라미터를 활용하자

위에 코드는 한번에 한 줄 만 읽을 수 있다. 한 번에 두줄을 읽거나 가장 자주 사용되는 단어를 반환하려면 동작을 파라미터화하는 것이다.
함수형 인터페이스를 이용해서 동작을 전달하는 예를 살펴보자.

```java
@Functionalinterface
public interface BufferedReaderProcessor {
  String process(BufferedReader b) throws IOException
} // 함수형 인터페이스라고 명시 

public String processFile(BufferedReaderProcessor p) throws IOException // 메서드로 사용 가능
```

#### 2-4 동작 실행

```java
public String processFile() throws IOException {
	try (BufferedReader br = new BufferedReader (new FileReader("moden.txt"))) {
		return p.process(br);
	} 
}

String oneLine = processFile((BufferedReader br) -> br.readLine());
```



