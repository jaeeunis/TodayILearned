# Modern Java In Action

## CHAPTER 3 람다 표현식

> 람다표현식은 메서드로 전달할 수 있는 **익명 함수**를 단순화한 것이라고 할 수 있다. 람다 표현식에는 이름은 없지만, 파라미터 리스트, 바디, 반환 형식, 발생할 수 있는 예외 리스트는 가질 수 있다. 람다를 이용하면 간결한 방식으로 코드를 전달할 수 있다. 

```java
(Coumputer c1, Computer c2) -> c1.getPrice().compreTo(c2.getPrice());
// 람다 파라미터                   // 람다 바디
```

<br>

### 1. 어디에, 어떻게 람다를 사용할까!?

#### 1-1 함수형 인터페이스

함수형인터페이스라는 문맥에서 람다표현식을 사용할 수 있다. **함수형 인터페이스**는 정확히 **하나의 추상 메서드를 지정하는 인터페이스**이다. 람다 표현식으로 함수형 인터페이스의 추상 메서드 구현을 직접 전달할 수 있으므로 **전체 표현식을 함수형 인터페이스의 인스턴스로 취급 할 수 있다.** ( 내 경우에는 람다표현식 그 자체가 함수형 인터페이스라는 것으로 이해했다. )

```java
public interface Predicate<T> {
		boolean test(T t);
}

Runnable r1 = () -> System.out.println("Hello World 1"); // 함수형 인터페이스 람다로 표현
public static void process(Runnable r) {
  	r.run();
}
process(() -> System.out.println("Hello World 2")); // 파라미터 값을 람다표현으로 표현
```

#### 1-2 함수 디스크립터

함수형 인터페이스의 추상 메서드 **시그니처(signature)**는 람다 표현식의 시그니처를 가리킨다. 람다 표현식의 시그니처를 서술하는 메서드를 **함수 디스크립터(function descripter)**라고 부른다. 위에서 Predicate 인터페이스의 유일한 추상 메서드 test는 int 인수와 boolean반환값이 있는 시그니처로 생각할 수 있다.

#### 1-3 왜 함수형 인터페이스를 인수로 받는 메서드에만 람다 표현식을 사용할 수 있을까?

자바에 함수형식을 추가하는 방법도 고려했지만 언어를 더이상 복잡하게 만들지 않는 것을 선택했다. 또한 대부분의 자바 프로그래가 하나의 추상 메서드를 갖는 인터페이스에 이미 익숙하다는 점을 고려했다. 

#### 1-4 @Functionalinterface 

새로운 자바 API를 살펴보면 @Functionallinterface 어노테이션이 추가되어 있다. 함수형 인터페이스를 가리키는 어노테이션이다. 인터페이스를 선언했지만 실제로 함수형 인터페이스가 아니면 컴파일러가 에러를 발생시킨다. 예를 들어 추상 메서드가 한 개 이상이라면 에러를 발생시킨다. ("Multiple nonoverriding abstract methods found in interface Jaeeun")

<br>

### 2. 람다 활용 : 실행 어라운드 패턴

자원 처리에 사용하는 순환 패턴은 자원은 열고, 처리한 다음에, 자원을 닫는 순서로 이루어진다. 즉 실제 자원을 처리하는 코드를 설정과 정리 두과정이 둘러싸는 형태를 갖는 형식의 코드를 **실행 어라운드 패턴(excute around pattern)**이라고 부른다.

```java
public String processFile() throws IOException {
	try (BufferedReader br = new BufferedReader (new FileReader("moden.txt"))) {
		return br.readLine(); // 실제 파일을 읽는 (실제 필요한 작업) 코드
	} 
}
```

#### 2-3 동작 파라미터를 활용하자

위에 코드는 한번에 한 줄 만 읽을 수 있다. 한 번에 두줄을 읽거나 가장 자주 사용되는 단어를 반환하려면 동작을 파라미터화하는 것이다.
함수형 인터페이스를 이용해서 동작을 전달하는 예를 살펴보자.

```java
@Functionalinterface
public interface BufferedReaderProcessor {
  String process(BufferedReader b) throws IOException
} // 함수형 인터페이스라고 명시 

public String processFile(BufferedReaderProcessor p) throws IOException // 메서드로 사용 가능
```

#### 2-4 동작 실행과 람다 전달

```java
public String processFile() throws IOException {
	try (BufferedReader br = new BufferedReader (new FileReader("moden.txt"))) {
		return p.process(br);
	} 
}

String oneLine = processFile((BufferedReader br) -> br.readLine());
```



### 3. 함수형 인터페이스 사용

#### 3-1 함수형 인터페이스의 종류

`java.util.function.Predicate<T>` : test 라는 추상 메서드를 정의하며 test는 제네릭 형식 T의 객체를 인수로 받아 불리언을 반환한다. T형식의 객체를 사용하는 불리언 표현식이 필요한 상황에서 Predicate 인터페이스를 사용할 수 있다. <br>
`java.util.function.Consumer<T>` : 제네릭 형식 T 객체를 받아서 void를 반환하는 accept 라는 추상 메서드를 정의한다. <br>
`java.util.function.Funtion<T,R>` :  제네릭 형식 T를 인수로 받아서 제네릭 형식 R 객체를 반환하는 추상 메서드 apply를 정의한다. 입력을 출력으로 매핑하는 람다를 정의할 때 Function 인터페이스를 활용할 수 있다.

#### 기본형 특화 !?

세개의 함수형 인터페이스는 모두 제네릭 함수형 인터페이스이다. 자바의 모든 형식은 참조형 아니면 기본형에 해당한다. 하지만 제네릭 파라미터에는 참조형만 사용할 수 있다. 제네릭의 내부구현 때문에 어쩔 수 없는 일이고, 이러한 기본형을 참조형으로 변환하는 기능을 **박싱** 반대로 참조형을 기본형으로 변환하는 일을 **언박싱**이라고 한다. 박싱과 언박싱이 자동으로 이루어지는 **오토박싱** 이라는 기능도 제공한다. 하지만 이런 변환 과정은 비용이 더 소모된다. (자세한 언박싱과 박싱에 대한 내용은 추후에 추가하도록)



### 4. 형식 검사, 형식 추론, 제약

#### 4-1 형식 검사

```java
List<Computer> isSamsung = filter(inventory, (Computer computer) -> computer.getBrand().equals("삼성"));
```

1.  filter 메서드의 선언을 확인한다.
2. filter 메서드는 두 번째 파라미터로 Predicate<Computer> 형식을 기대한다.
3. Predicate<Computer> 는 test라는 한 개의 추상 메서드를 정희하는 함수형 인터페이스이다.
4. test 메서드는 Computer를 받아 boolean 을 반환하는 함수 디스크립터를 묘사한다.
5. filter 메서드로 전달된 인수는 이와같은 요구사항을 만족해야 한다.



