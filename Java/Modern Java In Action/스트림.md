# Modern Java In Action

## CHAPTER 4 스트림

> 스트림은 자바8 API에 새로 추가된 기능이다. 스트림을 이용하면 **선언형** (즉, 데이터를 처리하는 임시 구현 코드 대신 질의로 표현 할 수 있다.)으로 컬렉션 데이터를 처리할 수 있다. 간단하게 말해서, 스트림이 데이터 컬렉션 반복을 멋지게 처리할 수 있다.
> 또한 스트림을 이용하면 멀티스레드 코드를 구현하지 않아도 데이터를 투명하게 병렬로 처리할 수 있다. 

<br>

### 4-1 스트림이란 무엇인가 ?

`스트림(stream)` : 정확하게 스트림이란 "데이터 처리 연산을 지원하도록 소스에서 추출된 연속된 요소로 정의할 수 있다" 

1. **연속된 요소** : 컬렉션과 마찬가지로 스트림은 특정 요소 형식으로 이루어진 연속된 값 집합의 인터페이스를 제공한다. 컬렉션은 자료구조이므로 컬렉션에서는 (ArrayList 또는 LinkedList를 사용할 것인지에 대한) 시간과 공간의 복잡성이 주를 이루지만 스트림은 filter, sorted, map 처럼 표현 계산식이 주를 이룬다. 

2. **소스** : 스트림은 컬렉션, I/O 자원 등의 데이터 제공 소스로부터 데이터를 소비한다. 정렬된 컬렉션으로 스트림을 생성하면 정렬이 그대로 유지된다.

3. **데이터 처리연산** : 스트림은 일반적으로 지원하는 연산과 데이터베이스와 비슷한 연산을 지원한다.

4. **파이프 라이닝** : 대부분의 스트림 연산은 스트림 연산끼리 연결해서 커다란 파이프 라인을 구성할 수 있도록 스트림 자신을 반환한다.

5. **내부 반복** : 반복자를 이용해서 명시적으로 반복하는 컬렉션과 달리 스트림은 내부 반복을 지원한다.

   

스트림을 사용하지 않고 컴퓨터 성능이 좋은 이름을 가져오기 위해서는 **가비지 변수**를 사용했다. hiperformanceComputerName을 구하기 위해서 중간 컨테이너 역할만 하는 변수이다. 

```java
List<Computer> hiperformanceComputer = new ArrayList<>();
for (Computer computer:inventory){
  	if (computer.getSpeed() > 200) {
      	hiperformanceComputer.add(computer);
    }
}

Collections.sort(hiperformanceComputer, new Comparator<Computer>() {
  public int compare(Computer computer1, Computer computer2) {
    return Integer.compare(computer1.getSpeed(), computer2.getSpeed());
  }
});

List<String> hiperformanceComputerName = new ArrayList<>();
for (Computer computer : hiperformanceComputer) {
  	hiperformanceComputerName.add(computer.getName());
}
```

하지만 스트림을 사용하면 **선언형**으로 코드를 구현할 수 있다. if 조건문 등의 제어 블록을 사용해서 어떻게 동작을 구현할지 지정할 필요없이 원하는 조건의 변수를 가져오는 동작을 수행할 수 있다. 

```java
List<String> hiperformanceComputerName = inventory.stream()
																									.filter(c -> c.getSpeed() > 200)
																									.sorted(comparing(Computer::getSpeed))
																									.map(Computer::getName)
																									.colled(toList());
```

위 처럼 `filter, sorted, map, collect` 같은 여러 빌딩 블록 연산을 연결해서 복잡한 데이터 처리 파이프라인을 만들 수 있다. 여러 연산을 파이프라인으로 연결해도 여전히 가독성과 명확성이 유지된다. 

<br>

#### 4-3 스트림 연산

스트림의 연산은 두 그룹으로 구분할 수 있다. 연결할 수 있는 스트림 연산을 중간 연산이라고 하며, 스트림을 닫는 연산을 최종 연산이라고 한다. 

##### 4-3.1 중간 연산 (intermediate operation) 

중간 연산은 다른 스트림을 반환한다. 따라서 여러 중간 연산을 연결해서 질의를 만들 수 있다. 중간 연산의 중요한 특징은 단말 연산을 스트림 파이프라인에 실행하기 전까지는 아무 연산도 수행하지 않는다는 것 (sorted, limit, distinct 등등 다양한 연산은 5장에서 만난다.)

`filter` : 람다를 인수로 받아 스트림에서 특정 요소를 제외시킨다. <br>
`map` : 람다를 이용해서 한 요소를 다른 요소로 변환하거나 정보를 추출한다. <br>

##### 4-3.2 최종 연산 (terminal operation)

최종 연산은 스트림 파이프라인에서 결과를 도출한다. 보통 최종 연산에 의해 List, Integer, void 등 스트림 이외의 결과가 반환된다. (forEach, count 등등)

`collect` : 스트림을 다른 형식으로 변환한다. 다양한 변환 방법을 인수로 받아 스트림에 누적된 요소를 특정 결과로 변환시키는 기능을 수행한다. 

<br>

#### 4-3 스트림과 컬렉션

자바의 기존 컬렉션과 스트림 모두 연속된 요소 형식의 값을 저장하는 자료구조의 인터페이스를 제공한다. **연속된** 이라는 표현은 순서와 상관없이가 아니라 순차적으로 값에 접근한다는 것이다. 
둘의 가장 큰 차이점은 데이터를 **언제 계산** 하느냐이다. 컬렉션은 현재 자료구조가 포함하는 모든 값을 메모리에 저장하는 자료구조다. 컬렉션의 모든 요소는 컬렉션에 추가하기 전에 계산되어야 한다. 반면에 스트림은 **요청할 때만 요소를 계산** 하는 고정된 자료구조다.
**사용자가 요청하는 값만 스트림에서 추출한다는 것이 핵심이다.** 

<br>

1. **딱 한번만 탐색할 수 있다** : 반복자와 마찬가지로 스트림은 한 번만 탐색할 수 있고, 다시 탐색하려면 초기 데이터 소스에서 새로운 스트림을 만들어야 한다. 
   딱!! 한번만 사용할 수 있다!! (인턴에서 파일럿 프로젝트를 하면서 처음 사용했던 스트림이 또 반복하려했을 때 에러가 났었는데 정확한 이유를 이제야 알았다..이래서 이론적인 공부도 참 중요하구나 다시한번 깨닫는다..)

```java
Stream<Apple> streams = apples.stream();
streams.forEach(System.out::println);
streams.forEach(System.out::println);
```

![image-20210806204911428](/Users/jaeeunlim/Library/Application Support/typora-user-images/image-20210806204911428.png)

2. **외부반복과 내부반복** : 컬렉션 인터페이스를 사용하려면 사용자가 직접 요소를 반복해야 한다. 이를 **외부 반복(external iteration)** 이라고 한다. ㅋㄹ렉션은 명시적으로 항목을 하나씩 가져와서 처리해야 한다. 반면에 스트림 라이브러리는 반복을 알아서 처리하고 결과 스트림값을 저장해주는 **내부 반복(internal iteration)**을 사용한다. 내부 반보을 이용하면 투명하게 병렬로 처리하거나 더 최적화된 다양한 순서로 처리할 수 있다. 외부 반복에서는 병렬성을 스스로 관리해야 한다. 자바8에서는 컬렉션과 비슷하지만 반복자가 없는 것을 절실하게 생각하면서 탄생했다. 
   (생각보다 자바 API의 탄생은 개발자들의 깊은 고민에서 나왔다는 생각이 든다. 새로운 라이브러리 또는 프레임워크를 사용할 때, 동작원리를 먼저 확인하는 습관을 길러야 겠다.)


#### 4-4 스트림 이용하기

스트림 파이프라인의 개념은 빌더 패턴과 비슷하다. 빌더 패턴에서는 호출을 연결해서 설정을 만든다. 그리고 준비된 설정에 build 메서드를 호출한다.